#!/usr/bin/perl

=head1 NAME

schow - Curses multi-area MH show

=cut

my($VERSION)='0.8';

use open qw(:locale);
use Getopt::Long;
use Pod::Usage;
use IO::Handle;
use List::Util qw(min max);
use Text::ParseWords;
use Text::Tabs;
use File::Basename;
use File::Temp qw(tempfile);
use Curses;
use Curses::UI;
use Data::Dumper;

=head1 SYNOPSIS

schow [<show options>]

=head2 Options

All command-line options to B<schow> which are not listed below are
passed unaltered and directly to L<show(1)>.

=over 8

=item -m or -mouse

Enable the mouse scroll wheel.  You may find that this affects your
ability to select text with your mouse for copy into the selection
buffer.  Holding down shift can help with this, or don't enable
the mouse.

=item -c or -compat

Set terminal compatibility mode, which tells curses to assume the
terminal is pretty uncapable, and perform all actions in the simplest
way.  This is sometimes necessary if the menu drawing boxes don't display
correctly.

=item -w or -wrapheader

Use line wrapping when constructing the header window.  By default,
long header lines are accessed via scrolling

=item -s or -source

Include a final message part consisting of the entire messsage source.

=item -i or -inversebar

Use the terminal's reverse video capability to invert the menu bar
so that it stands out more as a barrier between the header and
body of a message.

=item -b or -boldbar

Use the terminal's bold capability to make the menu bar stand out
more than normal.  Depending on your terminal settings, this may
or may not look different.

=item -e <program> or -editor <program>

Set the text editor used when requesting to edit attachments
of MIME type C<text/plain> to be C<program>.

=item -B or -nobeep

Disable terminal beep notifications.

=item -v or -version

Print version and exit

=item -h or -? or -help

print this short help, then exit.

=item -H or -manual

Print the full manual, then exit.

=item -L or -license

Print the software license, then exit.

=back

=cut

my(@OPTIONS)=qw(
	mouse|mice|wheel|pointer|m
	compat|simple|dumb|c
	wrapheader|wrapheaders|wraphead|w
	inversebar|i
	inversebar|inverse|i
	boldbar|bold|b
	source|view-source|s
	nobeep|B
	editor|e=s
	version|v
	help|h
	manual|H
	license|L
);
my(%ARG)=(
	'mouse'       => 0,
	'compat'      => 0,
	'inversebar'  => 0,
	'boldbar'     => 0,
	'nobeep'      => 0,
);

my(@MH_SETTINGS)=qw(
	editor pathproc showmimeproc lproc listmimeproc storemimeproc mhlproc
	scanproc pickproc libdir schow current-folder
);
my(%MH)=map(m/^([\w\/-]+?):\s+(.*?)\s*$/s,
	`mhparam -all; mhparam @MH_SETTINGS`);

$MH{'pathproc'}||='mhpath';
$MH{'path'}=`$MH{'pathproc'} +`; chomp($MH{'path'});
$MH{'current-folder'}||='inbox';
$MH{'folder'}=join('/', $MH{'path'}, $MH{'current-folder'});
$MH{'schow'}||='';
$MH{'listmimeproc'}||='mhlist';
$MH{'storemimeproc'}||='mhstore';
$MH{'mhlproc'}||=join('/', $MH{'libdir'}, 'mhl');
$MH{'scanproc'}||='scan';
$MH{'pickproc'}||='pick';
$MH{'editor'}||=$ENV{'EDITOR'} || $ENV{'VISUAL'} || 'vi';

unshift(@ARGV, shellwords($MH{'schow'}));

$Text::Tabs::tabstop=4;

Getopt::Long::Configure('pass_through', 'bundling_override', 'ignore_case');
unless(GetOptions(\%ARG, @OPTIONS)) {
     pod2usage(-verbose => 1, -exitval => 1);
} 

if($ARG{'version'}) {
	print basename($0), ' ', $VERSION, "\n";
	exit(0);
} elsif($ARG{'help'}) {
	pod2usage(-verbose => 1, -exitval => 0);
} elsif($ARG{'manual'}) {
	pod2usage(-verbose => 2, -exitval => 0);
} elsif($ARG{'license'}) {
	pod2usage(-verbose => 99, -exitval => 0,
		-sections => ['LICENSE', 'COPYRIGHT']);
}

$ENV{'ESCDELAY'}=100;

print "\n"x($ENV{'LINES'}-1) if($ENV{'LINES'});

=head1 DESCRIPTION

B<schow> divides the screen into multiple parts and displays a message
without the use of C<lproc>, it provides it's own pagination.  Instead
of an empty line between the header and the body, B<schow> has a menu
bar which contains information about the message and provides options
for accessing and saving attachments.  The header information and
menu stay at the top of the screen as you page through the message,
ensuring access to the context of the message throughout review.

=cut

my($CUI)=Curses::UI->new(
		-color_support  => 1,
		-mouse_support  => $ARG{'mouse'},
		-compat         => $ARG{'compat'},
		-debug          => 0,
	);
my($WIN)=$CUI->add('schow', 'Window');

my($HEAD, $MENU, $BAR, $MENU_PART, $MENU_VIEW, $STATUS, $BODY);

my($WIDTH)=$Curses::COLS;
my($HEADERS)=0;

my($MSG, $MSGFILE)=(undef, undef);
my(@PARTS)=();
my(%CACHE);

my(@SEL)=();

=pod

B<schow> is an C<mhshow> alternative/replacement.  In all practical ways, it
acts the same as C<mhshow> for interactive use.  Just as C<show> and C<mhshow>
do, it changes the C<cur> sequence when a message is viewed.

=cut

sub mark {
	my($msg)=@_;
	my(@mark)=($MH{'pickproc'}, '-sequence', 'cur', '-list');
	my($current)=IO::Handle->new;

	open($current, '-|', @mark, $msg);
	while(<$current>) {
		$MSG=$1 if(m/(\d+)/);
	}
	close($current);

	$MSGFILE=join('/', $MH{'folder'}, $MSG);

	return($MSG);
}

=head2 Features

=head3 Message Headers

The top of the screen holds the header information from the message.
The format of this content is stored in the users F<Mail> directory,
in a file named F<schow.headers>.  If this file doesn't exist, B<schow>
creates it.  You can modify the contents to suit your needs. If you
want to restore it to the default values, simply remove it and the
default will be installed the next time you run B<schow>.

This file will be interpreted by C<mhl> and follows all C<mhl> format
file conventions.  C<mhl> will be called with a C<-width> parameter
to specify the size of the screen in the case that the B<schow>
command-line parameter C<-wrapheaders> is used.  Otherwise, any header
which spans multiple lines will be joined into one long line.

=cut

my($HEADER_FORM)=<<'EOT';
;
; schow.headers
;
; Default format file for displaying headers with  schow.
; schow calls scanproc with this filter to display message header.
;
; To, Cc, and From are only displayed if non-empty
;
leftadjust,compwidth=9,overflowoffset=9,compress
Date:formatfield="%<(nodate{text})%{text}%|%(pretty{text})%>"
To:decode
cc:decode
From:decode
Subject:formatfield="%<{text}%(decode{text})%|<no subject>%>"
EOT

sub headers {
	my(@show)=($MH{'mhlproc'}, '-nobell', '-noclear', $MSGFILE);
	my($header, $form)=(IO::Handle->new, IO::Handle->new);
	my($formfile)=join('/', $MH{'path'}, 'schow.headers');
	my($width)=$ARG{'wrapheader'}?$WIDTH:1024;
	my(@head)=();
	local($Text::Tabs::tabstop)=8;
	local($_);

	$HEADERS=0;

	unless(-r $formfile) {
		open($form, '>', $formfile);
		print $form $HEADER_FORM;
		close($form);
	}

	unless($CACHE{'headers'}) {
		open($header, '-|', @show, '-width', $width, '-form', $formfile);
		while(<$header>) {
			chomp;

			if(m/^\s+(.*)$/ && length($head[-1])+length($1)<$width) {
				s/^\s+//;
				$head[-1]=~s/,$/, /;
				$head[-1].=expand($_);
			} else {
				push(@head, expand($_));
				$HEADERS++;
			}
		}
		close($header);
		if($?) {
			print STDERR "\n\rError reading headers\n";
			exit;
		}

		$CACHE{'headers'}=[@head];
	}
}

=head3 Multipart Messages

One of the most important advancements of B<schow> over the standard
C<show> or enhanced C<mhshow> commands is with respect to the treatment
of multipart messages and attachments.  B<schow> combines the tools
C<mhlist>, C<mhshow>, and C<mhstore> into one program (literally, as
it actually calls those programs to perform its work) whose purpose is
to simplfiy MH MIME message handling.

The display (e.g. non C<multipart/?> container) parts of a message will
be used by B<schow> to create an message part menu, provide an C<about>
menu option describing the message part, be used to provide other
message part options like opening, editing, and saving.

Because B<schow> provides such an easy and intuitive interface to
attachments, its behaviour is different from both the old and new
nmh C<mhshow> behaviour with respect to displaying the "body" of
the message.  By default nmh (prior to 1.6) would show each viewable
content part seperately.  With 1.6, nmh defaults to showing all the
appropriate C<text/?> parts.  B<schow> is different in that it inspects
each part to determine if it is part of the original message body, or
meant to be an attachment.  Based on this analysis, parts are marked
for default "body" view, or to only be accessed as an attachment.
Attachment parts which are of content type C<text/?> may still be viewed
inside B<schow>, just by themselves.

=cut

sub parts {
	my(@mhlist)=($MH{'listmimeproc'},
		'-disposition', '-verbose', '-noheaders');
	my($list)=IO::Handle->new;
	my($partw)=0;
	local($_);

	@PARTS=();
	%CACHE=();

	open($list, '-|', @mhlist);
	while(<$list>) {
		if(m{([\d\.]+)\s+([\w-]+/[\w-]+)\s+(\d+\w*)\s*(.*)}) {
			$partw=max($partw, length($1)) if(@PARTS);

			push(@PARTS, {
				'part'		=> $1,
				'type'		=> $2,
				'size'		=> $3,
				'description'	=> $4 || undef,
			});
		} elsif(m{^\s+([\w-]+)="?(.+?)"?\s*$}i) {
			$PARTS[-1]->{$1}=$2;
		} elsif(m{^\s+disposition\s+"?(.+?)"?\s*$}i) {
			$PARTS[-1]->{'disposition'}=$1;
		}
	}
	close($list);

	foreach $part (@PARTS) {
		next unless(ref($part) eq 'HASH' && %$part);

		if($part->{'dispositon'} || $part->{'name'} || $part->{'filename'}) {
			$part->{'attachment'}='yes';
		} elsif($part->{'type'}!~m/^text/i) {
			$part->{'attachment'}='yes';
		}

		if(exists($part->{'name'}) && exists($part->{'filename'})) {
			if($part->{'name'} eq $part->{'filename'}) {
				delete($part->{'name'});
			}
		} elsif(exists($part->{'name'})) {
			$part->{'filename'}=$part->{'name'};
			delete($part->{'name'});
		}

		if($part->{'filename'}) {
			$part->{'filename'}=basename($part->{'filename'});
			$part->{'filename'}=~s/[\s;&?*\\~]+/_/g;
			$part->{'filename'}=~s/[[:^print:]]+/_/g;
		}

		if(@PARTS>1) {
			$part->{'display'}=sprintf("%-${partw}s %s", $part->{'part'},
							$part->{'name'} ||
							$part->{'filename'} ||
							$part->{'description'} ||
							$part->{'type'}
						);
		} else {
			$part->{'display'}=$part->{'type'};
		}

		if(length($part->{'display'})>=30) {
			substr($part->{'display'}, 22, -6, '*');
		}
	}
}

=pod

A special message part may be listed if the C<-source> command-line
option is used.  This option creates a "message part" entry entitled
C<View Source> which contains the unmodified source text of the
entire email.  This option is useful if you like to review all the
message headers of an email, or if you wish to inspect the seperate
MIME parts for issues.

=cut

sub source {
	my(@mhpath)=($MH{'pathproc'});
	my($path, $raw)=(IO::Handle->new, IO::Handle->new);
	my($part)=int($PARTS[-1]{'part'}+1);
	my($msgfile);
	local($_);

	open($path, '-|', @mhpath, $MSG);
	while(<$path>) {
		chomp;
		$msgfile=$_;
	}
	close($path);

	return unless($msgfile && -s $msgfile);

	push(@PARTS, {
			'msg'		=> $MSG,
			'part'		=> $part,
			'type'		=> 'text/plain',
			'description'	=> 'View Message Source',
			'display'		=> 'View Source',
			'filename'	=> $msgfile,
			'size'		=> -s $msgfile,
		});

	open($raw, '<', $msgfile);
	while(<$raw>) {
		chomp;

		push(@{$CACHE{$PARTS[-1]}{'show'}}, expand($_));
	}
	$CACHE{$PARTS[-1]}{'source'}=1;
	close($raw);
}

=head3 About Parts

An additional feature of B<schow> is that, for each message part,
you can display the known information about that part.  This information
will contain the size, Content-Type, filename if one exists, dispostion,
and possibly more.  This can be helpful to get more information about
an attachment before deciding what to do with it.

For messages which cannot be displayed on a terminal screen, this is
the content which comes up when you first navigate to a message part.
This is really useful for images, audio files, etc.  From this screen,
you can choose to open or save the binary file.

=cut

sub info {
	my($part)=@_;

	unless($CACHE{$PARTS[$part]}{'info'}) {
		$CACHE{$PARTS[$part]}{'info'}=join("\n", '', map(
			sprintf('    %-15s %s', "$_:", $PARTS[$part]{$_}),
			sort(keys(%{$PARTS[$part]}))
		), '');
	}

	$BODY->text($CACHE{$PARTS[$part]}{'info'});
	#$BODY->focus();
}

=head3 Saving Message Parts

B<schow> comes with a built-in, familiar looking save file dialog
to help you save messages.  Directory navigation is part of the
dialog, and so you can select the directory and filename to save
the attachment.

=cut

sub save {
	my($part)=@_;
	my(@mhstore)=($MH{'storemimeproc'});
	my($file)=$CUI->savefilebrowser(
		-path		=> $ENV{'PWD'},
		-file		=> $PARTS[$part]{'filename'},
		-editfilename	=> 1,
	);

	if($PARTS[$part]{'part'} && $file) {
		system(@mhstore, '-outfile', $file, '-part', $PARTS[$part]{'part'});
	}
	$BODY->focus();
}

=head3 Opening Message Parts

B<schow> replaces C<mhshow> when it comes to the interactive display of
messages, but there is no reason for it to re-invent the wheel.  When
B<schow> doesn't know how to render a message part, it calls the good
old C<mhshow> binary to do it instead.  This means you only have to
configure message attachment programs for one tool, and the experience
is the same regardless of which tool you use.  This allows for a
consistent interface which is easy to switch between for those who
choose to do so.

B<schow> actually uses your MH C<showmimeproc> configuration, so if you
have an existing C<mhshow> wrapper, that will be used here.  Unfortunately,
this means that you cannot set C<showmimeproc> to B<schow>, as that will
break lots of things.  In the L<NOTES> section below, an example of
how to use B<schow> for the interactive commands C<show>, C<next>, and
C<prev> exists.

Some C<mhshow-show-type> configurations use the C<%F> parameter which
requires terminal input for the running program.  Because of this,
B<schow> will suspend the curses interface when opening attachments.
When C<mhshow> returns (which may be immediate for some content types,
then the interfaces restarts as well.  For those situations, you should
be very carefull that the program holds onto the temporary file, because
B<schow> will delete it the second it resumes control of the user
experience.  If you want message/rfc822 message
parts to be displayed with B<schow> you would need to configure C<mhshow>
to use B<schow> for that content type.

=cut

sub open {
	my($part)=@_;
	my(@show)=($MH{'showmimeproc'}, '-form', 'mhl.body');

	if($PARTS[$part]{'part'}) {
		$CUI->leave_curses();
		system(@show, '-part', $PARTS[$part]{'part'});
		$CUI->reset_curses();
	}
	$BODY->focus();
}

=head3 text/plain Alternative Viewing in an Editor

In addition to the default screen presentation of C<text/plain> message
parts, your favorite editor may also be invoked.  The editor is invoked
on a temporary file which is permissioned read/write.  So, you can make
changes to the message part, but you will need to save those changes to
an alternate location if you wish them to be preserved.

=cut

sub editor {
	my($part)=@_;
	my(@mhstore)=($MH{'storemimeproc'});
	my(@editor)=($ARG{'editor'} || $MH{'editor'});
	my($fh, $temp)=tempfile("schow${MSG}XXXXX", 'DIR' => $MH{'path'});

	if($PARTS[$part]{'msg'} && $temp) {
		system('cp', '-a', $PARTS[$part]{'filename'}, $temp);

		$CUI->leave_curses();
		system(@editor, $temp);
		$CUI->reset_curses();
	} elsif($PARTS[$part]{'part'} && $temp) {
		system(@mhstore, '-outfile', $temp, '-part', $PARTS[$part]{'part'});

		$CUI->leave_curses();
		system(@editor, $temp);
		$CUI->reset_curses();
	}
	unlink($temp);
	$BODY->focus();
}

=head3 Message Text

Any message parts which are of content type text and don't appear
to be attachments will be displayed in the standard message body
window after B<schow> is invoked.  B<schow> uses C<mhshow>,
or whatever you have set C<showmimeproc> to, for displaying the
message content.  This means that your standard HTML to text
conversion methods defined for C<mhshow> will be used by
B<schow> for content conversion.

=cut

sub show {
	my($part)=@_;
	my(@show)=($MH{'showmimeproc'}, '-textonly', '-inlineonly',
		'-form', 'mhl.body', '-markform', '/dev/null');
	my($body)=IO::Handle->new;
	my($type, $subtype)=split(m(/), $PARTS[$part]{'type'});
	my(@text)=();
	my(@parts)=();
	my($line)=0;
	my($empty)=0;

	unless($CACHE{$PARTS[$part]}{'show'}) {
		if($part) {
			push(@parts, '-part', $PARTS[$part]{'part'});
		} else {
			foreach my $part (@PARTS) {
				unless($part->{'attachment'}) {
					push(@parts, '-part', $part->{'part'});
				}
			}
		}

		open($body, '-|', @show, @parts);
		while(<$body>) {
			$line++;

			if(m/^\s*$/) {
				next if($empty++ > 1);
			} else {
				$empty=0;
			}

			if($line==1 && m|^part\s+[\d.]*\s+\w+/.*\d+\w*$|) {
				next;
			}

			if(m/^\s{8}/ && length>$WIDTH) {
				s/^(\s+)(.*?)\s*$/$1$2$1/;
				while(length>$WIDTH && s/^\s//) {
					s/\s$//;
				}
			}
			if($type eq 'application') {
				push(@text, $_);
			} else {
				push(@text, &email_wrap($_));
			}
		}
		close($body);

		foreach(@text) {
			s/\s+$//;
		}

		$CACHE{$PARTS[$part]}{'show'}=\@text;
	}

	$BODY->text(join("\n", @{$CACHE{$PARTS[$part]}{'show'}}));
	$BODY->draw(1);
	#$BODY->focus();
}

=pod

B<schow> uses its own line wrapping algorithm.  It is common for email
to contain long strings (e.g. URLs) which are wider than the screen.  It
tries to make the best decisions when this occurs.

=cut

sub email_wrap {
	my(@text)=();
	my($ll, $lw);
	local($_);

	foreach(@_) {
		foreach my $word (split(m/(?<=\s)/)) {
			$word=~s/\t/        /;

			unless(@text) {
				while($word) {
					push(@text, substr($word, 0, $WIDTH, ''));
				}
				next;
			}

			$ll=length($text[-1]);
			$lw=length($word);

			if($lw < $WIDTH) {
				if($ll+$lw <= $WIDTH) {
					$text[-1].=$word;
				} else {
					$text[-1]=~s/\s+$//;
					push(@text, $word);
				}
			} else {
				$text[-1].=substr($word, 0, $WIDTH-$ll, '');
				$text[-1]=~s/\s+$//;

				while($word) {
					push(@text, substr($word, 0, $WIDTH, ''));
				}
			}
		}
	}

	return(@text);
}

=head3 User Defined/Auxillary Actions

B<schow> provides an interface to augment the standard message part
view menu with user defined actions.  With the standard C<mhshow>
interface, you can only specify one program per content type or
subtype.  However, it is more often the case when document viewing
is emulated that different programs may work better for different
files.  This interface allows them to all be defined, and then the
user can pick the different methods until the best one is found.

This interface works very similar to the C<mhshow-show-type> interface.
If your F<.mh_profile> had the following lines defined:

  schow-pdf2txt-application/pdf: pdftotext -layout -nopgbrk %f -     
  schow-pdfinfo-application/pdf: pdfinfo %f

Other choices may be to list out archive file contents with your
preferred programs:

  schow-list-application/zip: unzip -t %f
  schow-list-application/x-tar: tar tvf %f
  schow-list-application/x-compressed-tar: tar tvf %f

Then, for messages with content type C<application> and subtype
C<pdf>, two additional view menu items will be available in addition
to the standard C<about>, C<save>, and C<open> which would normally
be there for PDF files.  Those entries will be entitled C<pdf2txt> and
C<pdfinfo>.  The first one will attempt to convert the PDF into an
ASCII text representation and display it in the standard body viewer.
The second one will display helpful information about the PDF, like
resolution and paper type to the standard body viewer window.  Whatever
the string is in the middle section, that will be the menu label.

Just like with C<mhshow>, first an attempt will be made to match
against the C<type/subtype>.  If that fails, then a match aginst
just C<type> is attempted.  It is probably best to avoid reusing
the same menu name to avoid confustion.  The following lines
will function in a deterministic fashion, but are not recommended
for people due to possible user confusion about which command will
be run when the item is selected.

  schow-display-image: xv '%f'
  schow-display-image/x-xcf: gimp '%f'

The C<%> sequences are the same as C<mhshow> and are as follows:

=over 8

=item %l

Prepend the message output with a simple line listing the part
number, MIME content type, and message part size.

=item %p

When a command line contains the C<%F> sequence, it drops out of
curses mode and runs the program interactively.  If the C<%p>
sequence is also present, you will be prompted before B<schow>
retakes control of the screen and re-enables curses.  Ironically,
this sequence is dropped from more recent versions of MH, but it
provides an important function for B<schow>.

=item %f

Replace with the filename of the temporary file.  If the C<%f>
is not surrounded by single quotes, they will be added.  When
C<%f> is used, the command will not have access to the terminal,
and control will remain with B<schow>.  The temporary file
will be available via the command line, and via STDIN.
C<%f> should be used whenever it is functional, it is the prefered
way to send a filename to a command.

=item %F

Replace with the filename of the temporary file, and provide the
command will access to terminal input.  If C<%F> is not surrounded
by single quotes, they will be added.  C<%F> should only ever be
used if terminal input is required.  When C<%F> is used, B<schow>
will suspend curses, provide full control to the command, and then
restablish control after the command has exited.

=item %{parameter}

Substitute in C<parameter> from the Content-Type field.  This field
will not automatically be quoted for you.

=item %a

Provide the full MIME content type as an argument to the command.

=item %s

Provide the MIME content subtype as an argument to the command.

=item %d

Provide the MIME message part description on the command-line.  If
this sequence is not surrounded by single quotes already, they will
be added.

=item %%

Produce a single percent (%) sign.

=back

=cut

sub user {
	my($view, $part)=@_;
	my($type, $subtype)=split(m(/), $PARTS[$part]{'type'});
	my(@mhstore)=($MH{'storemimeproc'});
	my(@show)=();
	my($body)=IO::Handle->new;
	my(@text)=();
	my($pause)=0;
	my($xstdin)=0;
	my($fh, $temp)=tempfile("schow${MSG}XXXXX", 'DIR' => $MH{'path'});
	local($_);

	unless($CACHE{$PARTS[$part]}{$view}) {
		if(exists($MH{"schow-$view-$type/$subtype"})) {
			push(@show, $MH{"schow-$view-$type/$subtype"});
		} elsif(exists($MH{"schow-$view-$type"})) {
			push(@show, $MH{"schow-$view-$type"});
		} else {
			$BODY->text('Cannot find an mh_profile entry for this type');
			return(1);
		}

		foreach(@show) {
			if(s|%l||g) {
				push(@text, sprintf('part %-8s %-25s %d',
					@{$PARTS[$part]}{'part', 'type', 'size'}));
			}
			if(s|%p||g) {
				$pause=1;
			}

			1 while(s|%\{(.*?)\}|$PARTS[$part]{$1}|);

			s|%a|$type/$subtype|g;
			s|'?%f'?|'$temp'|g;
			s|'?%F'?|'$temp'|g and $xstdin=1;
			s|%s|$subtype|g;
			s|'?%d'?|'$PARTS[$part]{"description"}'|g;
			s|%%|%|g;
		}

		system(@mhstore, '-outfile', $temp, '-part', $PARTS[$part]{'part'});

		if($xstdin) {
			$CUI->leave_curses();
			#mhshow uses shell interpolation, so I have to also :(
			if($xstdin) {
				system("@show");
			} else {
				system("@show <$temp");
			}
			if($pause) {
				print "\r                        \rPress [ENTER] to return";
				getc(STDIN);
			}
			$CUI->reset_curses();

			return(0);
		} else {
			#mhshow uses shell interpolation, so I have to also :(
			if($xstdin) {
				open($body, "@show |");
			} else {
				open($body, "@show <$temp |");
			}
			while(<$body>) {
				chomp;

				push(@text, $_);
			}
			close($body);

			unlink($temp);

			$CACHE{$PARTS[$part]}{$view}=\@text;
		}
	}

	$BODY->text(join("\n", @{$CACHE{$PARTS[$part]}{$view}}));
}

=pod

You should not try to name your menu items after the standard
ones of C<show>, C<about>, C<open>, C<save>, or C<editor>.  If you
do, they will be renamed to be suffixed by the number 2.  The built-in
methods are treaded specially, and cannot be overridden.

Also, please be advised that C<mhlist> only reports on the first 24
characters of a MIME type, and so that is all B<schow> has to go on.
There are no known applications where this poses an issue such that
two MIME types should be associated with different software.

B<schow> will taylor the menu of default actions based on the
message part content type, and it may seem like a good idea to
provide a standard function when one is missing, but that is simply
not possible.  The number C<2> will always be appended to ensure
the special processing of built-ins is not accidentally attempted.

=cut

foreach my $schow (grep(m|^schow-\w+-[\w./-]+$|, keys(%MH))) {
	my($view, $type)=($schow=~m/^schow-(\w+)-(.*)$/);

	if($view=~m/^(show|about|open|save|editor)$/) {
		$MH{join('-', 'schow', $view.'2', $type)}=$MH{$schow};
		delete($MH{$schow});
	} elsif(length($type)>24) {
		$MH{join('-', 'schow', $view, substr($type, 0, 24))}=$MH{$schow};
	}
}

=pod

When the view/context menu is constructed, the standard I<schow>
rendering will come first, followed by any user defined actions,
and then followed by the default choices.

=cut

sub view {
	local($_)=@_;
	my($type, $subtype)=split(m|/|);
	my(%user)=();
	my(@views)=();
	my($text)=join('|', qw(
			pgp-signature
			x-c?sh
			x-script
			sql
			xml
			.*\+xml
			.*\+json
		));

	foreach my $method (grep(m(^schow-.*?-$type(/$subtype)?$), keys(%MH))) {
		$user{$1}=1 if($method=~m(^schow-(.*?)-$type));
	}

	if(m(text/plain)) {
		@views=('show', sort(keys(%user)), 'about', 'editor', 'save');
	} elsif(m(text/)) {
		@views=('show', sort(keys(%user)), 'about', 'open', 'editor', 'save');
	} elsif(m(message/)) {
		@views=('show', sort(keys(%user)), 'about', 'open', 'save');
	} elsif(m(application/($text))i) {
		@views=('show', sort(keys(%user)), 'about', 'open', 'save');
	} else {
		@views=('about', sort(keys(%user)), 'open', 'save');
	}

	return([@views]);
}

=head3 View Actions

When performing a view action which does not have a standard text
representation, B<schow> will execute the requested action and then
reset the view to one which does.  For text based message parts, this
should be the C<show> action and for binary files, this is normally
the C<about> action.

=cut

sub action {
	my($menu)=@_;
	my($part)=$MENU_PART->get();
	my($view)=$MENU_VIEW->get();

	if($menu==$MENU_PART) {
		$MENU_VIEW->{-values}=&view($PARTS[$part]{'type'});
		$MENU_VIEW->{-selected}=0;
		$MENU_VIEW->layout();
	}

	$view=$MENU_VIEW->get();

	if($view eq 'save') {
		&save($part);
		$MENU_VIEW->{-selected}=0;
	} elsif($view eq 'open') {
		&open($part);
		$MENU_VIEW->{-selected}=0;
	} elsif($view eq 'editor') {
		&editor($part);
		$MENU_VIEW->{-selected}=0;
	}

	$view=$MENU_VIEW->get();

	if($view eq 'show') {
		&show($part);
	} elsif($view eq 'about') {
		&info($part);
	} else {
		unless(&user($view, $part)) {
			$MENU_VIEW->{-selected}=0;
			$view=$MENU_VIEW->get();
		}
	}

	if($ARG{'boldbar'}) {
		$MENU_PART->{-canvasscr}->attron(A_BOLD);
		$MENU_VIEW->{-canvasscr}->attron(A_BOLD);
	}
	$MENU_PART->{-canvasscr}->attron(A_UNDERLINE);
	$MENU_VIEW->{-canvasscr}->attron(A_UNDERLINE);

	$MENU_PART->draw();
	$MENU_VIEW->draw();
}

=head3 Zooming

The size of the viewable screen is the width and height of the terminal.
Text is wrapped at this width, and the screen can be scrolled down to view
the entire portion of content.  I, however, you need to make the display
area wider and pan around the content to read it, B<schow> supports a zoom
feature which will increase the line width by 20 characters at a time.  This
is sometimes very useful for text/html conversions which have the content
stored in tables.

=cut

sub zoom {
	my($delta)=@_;
	my($part)=$MENU_PART->get();

	if($delta<0 && $WIDTH<=40) {
		return(undef);
	} elsif($delta>0 && $WIDTH>=320) {
		return(undef);
	}

	foreach my $part (values(%CACHE)) {
		delete($part->{'show'}) if(ref($part) eq 'HASH' && !$part->{'source'});
	}
	$WIDTH+=$delta;
	$ENV{'COLUMNS'}=$WIDTH;

	&show($part);
}

=head2 Interface

=head3 Layout

The B<schow> window has three areas which move progressively down the screen.
The placement and order of the windows non-configurable.

The top area is reserved for the mail header.  Its height is, by default,
equal to that of the number of headers displayed.  Each header takes up only
one line, and is scrolled past the end of the screen.  The header section
uses a file in your F<Mail> directory called F<schow.headers>.  You can
change the headers you would like to see by editing this file.  The default
file contains I<Date>, I<From>, I<To>, I<Cc> (if present), and I<Subject>.

The middle area is a single line menu/status bar.  It will contain a
drop-down list for the different available message parts, and one for
a menu of ways to view that content.  The current message number will be
printed to the far right, and just to its left will be any additional
information about the message available to B<schow>.

The bottom section is the largest (unless your screen is really short) and
contains the body of the message text.  This is a scrollable area which
moves up, down, left, and right if necessary.  The body supports the
standard key strokes to move around, and supports a search interface.
When scrolling in the body, the header and menu will remain immobile.

=cut

sub window {
	$WIN->delete('head');
	$WIN->delete('menu');
	$WIN->delete('body');

	$HEAD=$WIN->add('head', 'TextViewer',
		-height       => $HEADERS,
		-focusable    => 0,
		-text         => join("\n", @{$CACHE{'headers'}}),
		-nobeep       => $ARG{'nobeep'},
	);
	$MENU=$WIN->add('menu', 'Container',
		-y            => $HEADERS,
		-height       => 1,
	);
	$BODY=$WIN->add('body', 'TextViewer',
		-y            => $HEADERS+1,
		-showoverflow => 0,
		-nobeep       => $ARG{'nobeep'}
	);
}

=head3 Menus

The first (leftmost) drop-down menu is for the message parts.  This
menu is not focusable/usable if the message contains only one
message part.  It does not contain any multipart MIME parts/containers.
Only display capable message parts will be listed in the menu.

The second (right) drop-down lists the view options for the current
message part.  This is a context menu, and changes based on the
message part.  When switching from one message part to another,
the context resets to the default.

=cut

sub menu {
	my($selected)=ref($MENU_PART)?($MENU_PART->get()):0;
	my($indexes)=[];
	my($labels)={};
	my($views)=[];

	for(my $i=0; $i<@PARTS; $i++) {
		next if($PARTS[$i]{'type'}=~m/multipart/);

		$labels->{$i}=$PARTS[$i]{'display'};
		push(@$indexes, $i);
	}

	$views=&view($PARTS[$part]{'type'});

	$BAR=$MENU->add('bar', 'Label',
		-width         => $Curses::COLS,
		-textalignment => 'right',
		-reverse       => $ARG{'inversebar'},
		-underline     => !$ARG{'inversebar'},
		-bold          => $ARG{'boldbar'},
		-paddingspaces => 1,
		-text		=> $MSG.' ',
	);

	$MENU_PART=$MENU->add('part', 'Popupmenu',
		-x            => 2,
		-values       => $indexes,
		-labels       => $labels,
		-selected     => $selected,
		-wraparound   => 1,
		-onchange     => \&action,
		-sbborder     => 0,
		-nobeep       => $ARG{'nobeep'},
	);

	$MENU_VIEW=$MENU->add('view', 'Popupmenu',
		-x            => $MENU_PART->width()+3,
		-width        => 12,
		-values       => $views,
		-selected     => 0,
		-wraparound   => 1,
		-onchange     => \&action,
		-sbborder     => 0,
		-nobeep       => $ARG{'nobeep'},
	);
	$STATUS=$MENU->add('status', 'Label',
		-x             => $MENU_PART->width()+$MENU_VIEW->width()+4,
		-width         => $Curses::COLS
						-length($BAR->get())
						-$MENU_PART->width()
						-$MENU_VIEW->width()
						-5,
		-textalignment => 'right',
		-paddingspaces => 1,
		-reverse       => $ARG{'inversebar'},
		-underline     => !$ARG{'inversebar'},
		-bold          => $ARG{'boldbar'},
	);

	$MENU->set_draworder('bar', 'part', 'view', 'status');
}

=head3 Status

To the right of drop-down menus is the status bar section of the
menu/status bar.  Normally, this only contains the message number.
However, if there is other important information B<schow> needs to
relay to the viewer, it will be placed here.

If the message is really, really important, then it will blink.

=cut

sub status {
	$STATUS->text(join(' ', @_));
	$STATUS->blink(0);
}

sub alert {
	$STATUS->text(join(' ', @_));
	$STATUS->blink(1);
}

=head3 Key Bindings

The key bindings for moving around are designed to be as compatible
as possible with the L<more(1)> and L<less(1)> programs which are
most often used to paginate message by MH users.

=over 8

=item >, ALT+RIGHT-ARROW

The greater than symbol or ALT + the right arrow key will scroll the
header section of the screen to the right 2 characters (if there is
anything to scroll for).  The header section is not capable of
accepting focus, and this is the only way to see more content (if 
there is any).

=item <, ALT+LEFT-ARROW

The less than symbol or ALT + the left arrow key will scroll the
header section of the screen to the left 2 characters (if there is
anything to scroll for).  The header section is not capable of
accepting focus, and this is the only way to return to the header
keys.

=item h, LEFT-ARROW, BACKSPACE, CTRL+B

Scroll the screen to the left by one character.

=item l, RIGHT-ARROW

Scroll the screen to the right by one character.

=item ^

Warp the screen to the leftmost position, showing the beginning of message
body lines.

=item $

Warp the screen to the rightmost position, showing the last characters
on message body lines.  This is based on the width of the buffer, the
lines you are currently viewing may not have lines that long and so it
is possible for the screen to appear empty.

=item k, UP-ARROW, p, P, CTRL+P, y, Y, CTRL+K

Scroll the body window up one line.

=item b, B, w, W, PAGE-UP, [

Scroll the body window up one page.

=item u, U, CTRL+U

Scroll the body window up 11 lines, which is the quivalent of about a half
page on many setups.

=item j, DOWN-ARROW, s, S, CTRL+N, e, E, ENTER

Scroll the body window down 1 line.

=item f, F, CTRL+F, z, Z, SPACE, PAGE-DOWN, ]

Scroll the body window down by a page.

=item d, D, CTRL+D

Scroll the body window down 11 lines, which is the quivalent of about a
half page on many setups.

=item mouse-wheel

If your terminal supports mouse events, then the scroll wheel will scroll
the screen up and down as you roll the wheel forward and backward,
repectively.

=item CTRL+mouse-wheel

If your terminal supports mouse events, then turning the scroll wheel
while holding down the Control key will have the effect of scrolling
the body left and right.

=item ALT+mouse-wheel

If your terminal supports mouse events, then turning the  scroll wheel
while holding down the Alt key will h ave the effect of scrolling the 
header window right and left, similar to how ALT+RIGHT-ARROW or ">" moves
the header window to the right.

=item g, HOME

Scroll to the first page of the message.

=item G, END

Scroll to the last page of the message.

=item TAB

Cycle through the window focus items to the next item.  The three items are
(in this order):

=over 8

=item 1 Body window

=item 2 Message part

=item 3 View/context drop-down
 
=back

If the message is not a MIME message, or contains only one message part,
the the 2nd item "Message part" is skipped.

=item SHIFT+TAB

Cycle backwards through the window focus items.  This moves in a backwards
fashion (1, 3, 2, 1, ...) from C<TAB> but is otherwise the same.

=item a, A

Warp focus to the message part drop-down menu.  Think C<a> for attachments.

=item v, V

Warp focus to the view/context drop-down menu.

=item LEFT-ARROW, RIGHT-ARROW (Menu focus only)

When either of the menus are in focus, the left and right arrow keys no longer
affect the body, and instead switch between the two.  Since there are only
two items, left and right always cycle to the other one.

=item UP-ARROW, DOWN-ARROW (Menu focus only)

These keys perform slightly differently on the menu bar.  When used on
the message part menu, the drop-down will not open, but the body will
switch to the next (or previous) message part based on the arrow.
However, when used on the view/context menu, the menu drop-down will
open, and you can then select the correct view.

=item +, =

Zoom in on the screen by increasing the width available for email rendering
by 20 characters.  If your screen width is 80 characters, this will give you
a 100 character virtual screen.  Each time you zoom, you will increase the
virtual width by 20 characters.  This is useful sometimes when rendering
email, especially email converted from HTML using tables.

=item -, _

Zoom out on the screen, decreasing the width available for email rendring
by 20 characters.  This function is the inverse of the previous zoom in.

=item ESCAPE

Warp focus to the body window.

=item /

Initiate a forward search.

=item ?

Initiate a backward search.

=item n, N

Move to the next message scheduled to be viewed.  If there are no
more messages to be viewed, exit.  This key binding is useful when
you request to show multiple message, either directly or through
the use of a sequence.

=item q, Q, x, X, CTRL+C

Exit B<schow>.  If there are other message left to be viewed,
exit anyway.

=item r, R, CTRL+R, CTRL+L

Redraw the screen.

=back

=cut

sub bindings {
	my($wheel_up)=BUTTON4_PRESSED;
	my($wheel_down)=BUTTON4_PRESSED<<5;   #BUTTON5_PRESSED not defined!!
	my($c_wheel_up)=BUTTON_CTRL|$wheel_up;
	my($c_wheel_down)=BUTTON_CTRL|$wheel_down;
	my($a_wheel_up)=BUTTON_ALT|$wheel_up;
	my($a_wheel_down)=BUTTON_ALT|$wheel_down;

	sub BINDc(&$@) { $_[1]->set_binding($_[0], @_[2 .. $#_]) }
	sub BINDs($$@) { $_[1]->set_binding($_[0], @_[2 .. $#_]) }
	sub hsend {
		foreach my $key (@_) {
			$HEAD->process_bindings($key);
		}
		$BODY->focus();
	}
	sub bsend {
		foreach my $key (@_) {
			$BODY->process_bindings($key);
		}
		$BODY->focus();
	}

	#TextEditor counts the newline in width AND things you need a +1
	$BODY->set_routine('cursor-right', sub {
		my($cur_hscroll)=$BODY->{-xscrpos};
		my($max_hscroll)=$BODY->{-hscrolllen} - $BODY->canvaswidth - 2;

		return $BODY->dobeep if($cur_hscroll >= $max_hscroll);

		Curses::UI::TextEditor::cursor_right(@_);
	});

	#Slide Head:
	BINDc { &hsend((KEY_RIGHT())x2) }  $WIN=>( '>', '.', "\e261-1" );
	BINDc { &hsend((KEY_LEFT())x2) }   $WIN=>( '<', ',', "\e260-1" );
	BINDc { &hsend((KEY_UP())) }       $WIN=>( "\e259-1" );
	BINDc { &hsend((KEY_DOWN())) }     $WIN=>( "\e258-1" );

	#Editor motions:
	BINDs 'cursor-scrlinestart',       $BODY=>( '^' );
	BINDs 'cursor-scrlineend',         $BODY=>( '$' );
	BINDs 'cursor-left',               $BODY=>( KEY_BACKSPACE() );
	BINDs 'cursor-up',                 $BODY=>( 'p', 'P', 'y', 'Y', "\cK" );
	BINDs 'cursor-pageup',             $BODY=>( 'b', 'B', 'w', 'W' );
	BINDc { &bsend((KEY_UP())x11) }    $BODY=>( 'u', 'U', "\cU" );
	BINDs 'cursor-home',               $BODY=>( 'g' );

	BINDs 'cursor-down',               $BODY=>( 's', 'S', 'e', 'E', KEY_ENTER() );
	BINDs 'cursor-pagedown',           $BODY=>( 'f', 'F', "\cF", 'z', 'Z' );
	BINDc { &bsend((KEY_DOWN())x11) }  $BODY=>( 'd', 'D', "\cD" );
	BINDs 'cursor-end',                $BODY=>( "\e[8~", 'G' );

	if($Curses::UI::ncurses_mouse) {
		#Down & Up are down and up
		$BODY->set_mouse_binding( sub { &bsend(KEY_UP()) }, $wheel_up);
		$BODY->set_mouse_binding( sub { &bsend(KEY_DOWN()) }, $wheel_down);

		#CTRL+Down & CTRL+Up are right and left
		$BODY->set_mouse_binding( sub { &bsend(KEY_LEFT()) }, $c_wheel_up);
		$BODY->set_mouse_binding( sub { &bsend(KEY_RIGHT()) }, $c_wheel_down);

		#ALT+Down & ALT+Up are header right and left
		$BODY->set_mouse_binding( sub { &hsend(KEY_LEFT()) }, $a_wheel_up);
		$BODY->set_mouse_binding( sub { &hsend(KEY_RIGHT()) }, $a_wheel_down);
	}

	#Cycle:
	if(@PARTS>1) {
		BINDc { $MENU_PART->focus() } $BODY=>( "\t" );
		BINDc { $MENU_PART->focus() }  $WIN=>( 'a', 'A' );
	} else {
		BINDc { $MENU_VIEW->focus() } $BODY=>( "\t" );
	}
	BINDc { $MENU_VIEW->focus() }      $BODY=>( KEY_BTAB );
	BINDc { $MENU_VIEW->focus() }       $WIN=>( 'v', 'V' );

	BINDc { $MENU_VIEW->focus() } $MENU_PART=>( KEY_LEFT, KEY_RIGHT, "\t" );
	BINDc { $BODY->focus() }      $MENU_PART=>( KEY_BTAB );

	if(@PARTS>1) {
		BINDc { $MENU_PART->focus() }
		                         $MENU_VIEW=>( KEY_LEFT, KEY_RIGHT, KEY_BTAB);
	} else {
		BINDc { 'noop'; }        $MENU_VIEW=>( KEY_LEFT, KEY_RIGHT );
		BINDc { $BODY->focus() } $MENU_VIEW=>( KEY_BTAB );
	}
	BINDc { $BODY->focus() }      $MENU_VIEW=>( "\t" );

	#View menu:
	BINDs 'open-popup',           $MENU_VIEW=>( KEY_UP, KEY_DOWN );

	#Zoom:
	BINDc { &zoom(20) }                 $CUI=>( '+', '=' );
	BINDc { &zoom(-20) }                $CUI=>( '-', '_' );

	#Global Keys
	BINDc { $BODY->focus() }            $CUI=>( "\e" );
	BINDc { $CUI->mainloopExit }        $CUI=>( 'n', 'N', "\cN" );
	BINDc { exit($CUI->mainloopExit) }  $CUI=>( 'q', 'Q', 'x', 'X', "\cC" );
	BINDc { $CUI->{-canvasscr}->redrawwin() }
	                                    $CUI=>( 'r', 'R', "\cR", "\cL" );
}

=head2 Displaying Messages

Unlike C<show> and C<mhshow>, B<schow> does not concatenate messages
if multiple are requested.  Instead, it provides an interface to
view them in succession.  The first message will be displayed
independently.  If the user enters either the C<n>, C<N>, or C<CTRL+N>
keys, the display window will close and a new one will open for the
next message.

=cut

sub display {
	my($msg)=@_;

	&parts();
	&source() if($ARG{'source'});
	&headers();

	&window();
	&menu();
	&bindings();

	&action($MENU_PART);

	$BODY->focus();

	$CUI->mainloop;

	return;
}

=pod

If the message request is for a sequence, the sequence will be
expanded and each message will be displayed as described above.
In all cases, the last message actually displayed will be the
message which is stored in the C<cur> sequence.

=cut

sub messages {
	my(@msgs)=();

	foreach my $seq (@_) {
		push(@msgs, shellwords(`$MH{'pickproc'} $seq`));
	}

	foreach my $msg (@msgs) {
		%CACHE=();
		&mark($msg);
		&display($msg);
	}
}

=pod

And, of course, if no message is specified, then the C<cur> sequence
will be used.

=cut

STDOUT->autoflush(1);
STDERR->autoflush(1);

if(@ARGV) {
	&messages(@ARGV);
} else {
	&messages('cur');
}

END {
	if(defined($CUI)) {
		$CUI->leave_curses();
		print "\n";
	}
}

=head1 NOTES

B<schow> can be called directly, or configured as your MIME show proc
for specific binaries.
C<DO NOT SET schow AS showmimeproc IN YOUR .mh_profile>.
Doing so will have disasterous consequences for any program expecting
to read from C<mhshow>, really please don't try it.  B<schow> itself,
needs access to the C<mhshow> binary, and looks at the C<showmimeproc>
variable in your F<.mh_profile> to find it.  You can, however,
specify that standard interactive commands use B<schow> for displaying
MIME message by placing the following in your F<.mh_profile>:

  show: -showmimeproc schow
  prev: -showmimeproc schow
  next: -showmimeproc schow

Assuming, of course, that B<schow> is in your path.  If you prefer to use
the standard commands most of the time, and save B<schow> for occasions
where messages are complex, remember that C<schow>, C<schow prev>, and
C<schow next> will work the same as C<show>, C<prev>, and C<next>,
respectively.

=head1 AUTHOR

William Totten

=head1 LICENSE

BSD 3-Clause License

=head1 COPYRIGHT

  Copyright (c) 2017, William Totten
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  
  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=cut

