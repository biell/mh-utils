#!/usr/bin/perl

=head1 NAME

schow - Curses multi-area MH show

=cut

my($VERSION)='0.8';

use Getopt::Long;
use Pod::Usage;
use IO::Handle;
use List::Util qw(min max);
use Text::ParseWords;
use Text::Tabs;
use File::Basename;
use File::Temp qw(tempfile);
use Curses;
use Curses::UI;

=head1 SYNOPSIS

schow [<show options>]

=head2 Options

All command-line options to B<schow> which are not listed below are
passed unaltered and directly to L<show(1)>.

=over 8

=item -c or -compat

Set terminal compatibility mode, which tells curses to assume the
terminal is pretty uncapable, and perform all actions in the simplest
way.  This is sometimes necessary if the menu drawing boxes don't display
correctly.

=item -w or -wrapheader

Use line wrapping when constructing the header window.  By default,
long header lines are accessed via scrolling

=item -s or -source

Include a final message part consisting of the entire messsage source.

=item -i or -inversebar

Use the terminal's reverse video capability to invert the menu bar
so that it stands out more as a barrier between the header and
body of a message.

=item -b or -boldbar

Use the terminal's bold capability to make the menu bar stand out
more than normal.  Depending on your terminal settings, this may
or may not look different.

=item -e <program> or -editor <program>

Set the text editor used when requesting to edit attachments
of MIME type C<text/plain> to be C<program>.

=item -B or -nobeep

Disable terminal beep notifications.

=item -v or -version

Print version and exit

=item -h or -? or -help

print this short help, then exit.

=item -H or -manual

Print the full manual, then exit.

=item -L or -license

Print the software license, then exit.

=back

=cut

my(@OPTIONS)=qw(
	compat|simple|dumb|c
	wrapheader|wrapheaders|wraphead|w
	inversebar|i
	inversebar|inverse|i
	boldbar|bold|b
	source|view-source|s
	nobeep|B
	editor|e=s
	version|v
	help|h
	manual|H
	license|L
);
my(%ARG)=(
	'inversebar'  => 0,
	'boldbar'     => 0,
	'nobeep'      => 0,
);

my(@MH_SETTINGS)=qw(
	editor pathproc showmimeproc lproc listmimeproc storemimeproc mhlproc
	scanproc pickproc libdir schow current-folder
);
my(%MH)=map(m/^([\w\/-]+?):\s+(.*?)\s*$/s,
	`mhparam -all; mhparam @MH_SETTINGS`);

$MH{'pathproc'}||='mhpath';
$MH{'path'}=`$MH{'pathproc'} +`; chomp($MH{'path'});
$MH{'current-folder'}||='inbox';
$MH{'folder'}=join('/', $MH{'path'}, $MH{'current-folder'});
$MH{'schow'}||='';
$MH{'listmimeproc'}||='mhlist';
$MH{'storemimeproc'}||='mhstore';
$MH{'mhlproc'}||=join('/', $MH{'libdir'}, 'mhl');
$MH{'scanproc'}||='scan';
$MH{'pickproc'}||='pick';
$MH{'editor'}||=$ENV{'EDITOR'} || $ENV{'VISUAL'} || 'vi';

unshift(@ARGV, shellwords($MH{'schow'}));

$Text::Tabs::tabstop=4;

Getopt::Long::Configure('pass_through', 'bundling_override', 'ignore_case');
unless(GetOptions(\%ARG, @OPTIONS)) {
     pod2usage(-verbose => 1, -exitval => 1);
} 

if($ARG{'version'}) {
	print basename($0), ' ', $VERSION, "\n";
	exit(0);
} elsif($ARG{'help'}) {
	pod2usage(-verbose => 1, -exitval => 0);
} elsif($ARG{'manual'}) {
	pod2usage(-verbose => 2, -exitval => 0);
} elsif($ARG{'license'}) {
	pod2usage(-verbose => 99, -exitval => 0,
		-sections => ['LICENSE', 'COPYRIGHT']);
}

$ENV{'ESCDELAY'}=100;

print "\n"x($ENV{'LINES'}-1) if($ENV{'LINES'});

=head1 DESCRIPTION

B<schow> divides the screen into multiple parts and displays a message
without the use of C<lproc>, it provides it's own pagination.  Instead
of an empty line between the header and the body, B<schow> has a menu
bar which contains information about the message and provides options
for accessing and saving attachments.  The header information and
menu stay at the top of the screen as you page through the message,
ensuring access to the context of the message throughout review.

=cut

my($CUI)=Curses::UI->new(
		-mouse_support  => 1,
		-color_support  => 1,
		-compat         => $ARG{'compat'},
		-debug          => 0,
	);
my($WIN)=$CUI->add('schow', 'Window');

my($HEAD, $MENU, $BAR, $MENU_PART, $MENU_VIEW, $BODY);

my($WIDTH)=$Curses::COLS;
my($HEADERS)=0;

my($MSG, $MSGFILE)=(undef, undef);
my(@PARTS)=();
my(%CACHE);

=pod

B<schow> is an C<mhshow> alternative/replacement.  In all practical ways, it
acts the same as C<mhshow> for interactive use.  Just as C<show> and C<mhshow>
do, it changes the C<cur> sequence when a message is viewed.

=cut

sub mark {
	my($msg)=@_;
	my(@mark)=($MH{'pickproc'}, '-sequence', 'cur', '-list');
	my($current)=IO::Handle->new;

	open($current, '-|', @mark, $msg);
	while(<$current>) {
		$MSG=$1 if(m/(\d+)/);
	}
	close($current);

	$MSGFILE=join('/', $MH{'folder'}, $MSG);

	return($MSG);
}

=head2 Message Headers

The top of the screen holds the header information from the message.
The format of this content is stored in the users F<Mail> directory,
in a file named F<schow.headers>.  If this file doesn't exist, B<schow>
creates it.  You can modify the contents to suit your needs. If you
want to restore it to the default values, simply remove it and the
default will be installed the next time you run B<schow>.

This file will be interpreted by C<mhl> and follows all C<mhl> format
file conventions.  C<mhl> will be called with a C<-width> parameter
to specify the size of the screen in the case that the B<schow>
command-line parameter C<-wrapheaders> is used.  Otherwise, any header
which spans multiple lines will be joined into one long line.

=cut

my($HEADER_FORM)=<<'EOT';
;
; schow.headers
;
; Default format file for displaying headers with  schow.
; schow calls scanproc with this filter to display message header.
;
; To, Cc, and From are only displayed if non-empty
;
leftadjust,compwidth=9,overflowoffset=9,compress
Date:formatfield="%<(nodate{text})%{text}%|%(pretty{text})%>"
To:decode
cc:decode
From:decode
Subject:decode,formatfield="%<{text}%{text}%|<no subject>%>"
EOT

sub headers {
	my(@show)=($MH{'mhlproc'}, '-nobell', '-noclear', $MSGFILE);
	my($header, $form)=(IO::Handle->new, IO::Handle->new);
	my($formfile)=join('/', $MH{'path'}, 'schow.headers');
	my($width)=$ARG{'wrapheader'}?$WIDTH:1024;
	my(@head)=();
	local($Text::Tabs::tabstop)=8;
	local($_);

	unless(-r $formfile) {
		open($form, '>', $formfile);
		print $form $HEADER_FORM;
		close($form);
	}

	unless($CACHE{'headers'}) {
		open($header, '-|', @show, '-width', $width, '-form', $formfile);
		while(<$header>) {
			chomp;

			if(m/^\s+(.*)$/ && length($head[-1])+length($1)<$width) {
				s/^\s+//;
				$head[-1]=~s/,$/, /;
				$head[-1].=expand($_);
			} else {
				push(@head, expand($_));
				$HEADERS++;
			}
		}
		close($header);
		if($?) {
			print STDERR "\n\rError reading headers\n";
			exit;
		}

		$CACHE{'headers'}=[@head];
	}
}

=head2 Multipart Messages

One of the most important advancements of B<schow> over the standard
C<show> or enhanced C<mhshow> commands is with respect to the treatment
of multipart messages and attachments.  B<schow> combines the tools
C<mhlist>, C<mhshow>, and C<mhstore> into one program (literally, as
it actually calls those programs to perform its work) whose purpose is
to simplfiy MH MIME message handling.

The display (e.g. non C<multipart/?> container) parts of a message will
be used by B<schow> to create an message part menu, provide an C<about>
menu option describing the message part, be used to provide other
message part options like opening, editing, and saving.

Because B<schow> provides such an easy and intuitive interface to
attachments, its behaviour is different from both the old and new
nmh C<mhshow> behaviour with respect to displaying the "body" of
the message.  By default nmh (prior to 1.6) would show each viewable
content part seperately.  With 1.6, nmh defaults to showing all the
appropriate C<text/?> parts.  B<schow> is different in that it inspects
each part to determine if it is part of the original message body, or
meant to be an attachment.  Based on this analysis, parts are marked
for default "body" view, or to only be accessed as an attachment.
Attachment parts which are of content type C<text/?> may still be viewed
inside B<schow>, just by themselves.

=cut

sub parts {
	my(@mhlist)=($MH{'listmimeproc'},
		'-disposition', '-verbose', '-noheaders');
	my($list)=IO::Handle->new;
	my($partw)=0;
	local($_);

	open($list, '-|', @mhlist);
	while(<$list>) {
		if(m{([\d\.]+)\s+([\w-]+/[\w-]+)\s+(\d+\w*)\s*(.*)}) {
			$partw=max($partw, length($1)) if(@PARTS);

			push(@PARTS, {
				'part'		=> $1,
				'type'		=> $2,
				'size'		=> $3,
				'description'	=> $4 || undef,
			});
		} elsif(m{^\s+([\w-]+)="?(.+?)"?\s*$}i) {
			$PARTS[-1]->{$1}=$2;
		} elsif(m{^\s+disposition\s+"?(.+?)"?\s*$}i) {
			$PARTS[-1]->{'disposition'}=$1;
		}
	}
	close($list);

	foreach $part (@PARTS) {
		next unless(ref($part) eq 'HASH' && %$part);

		if($part->{'dispositon'} || $part->{'name'} || $part->{'filename'}) {
			$part->{'attachment'}='yes';
		} elsif($part->{'type'}!~m/^text/i) {
			$part->{'attachment'}='yes';
		}

		if(exists($part->{'name'}) && exists($part->{'filename'})) {
			if($part->{'name'} eq $part->{'filename'}) {
				delete($part->{'name'});
			}
		} elsif(exists($part->{'name'})) {
			$part->{'filename'}=$part->{'name'};
			delete($part->{'name'});
		}

		if($part->{'filename'}) {
			$part->{'filename'}=basename($part->{'filename'});
			$part->{'filename'}=~s/[\s;&?*\\~]+/_/g;
			$part->{'filename'}=~s/[[:^print:]]+/_/g;
		}

		if(@PARTS>1) {
			$part->{'display'}=sprintf("%-${partw}s %s", $part->{'part'},
							$part->{'name'} ||
							$part->{'filename'} ||
							$part->{'description'} ||
							$part->{'type'}
						);
		} else {
			$part->{'display'}=$part->{'type'};
		}

		if(length($part->{'display'})>=30) {
			substr($part->{'display'}, 22, -6, '*');
		}
	}
}

=pod

A special message part may be listed if the C<-source> command-line
option is used.  This option creates a "message part" entry entitled
C<View Source> which contains the unmodified source text of the
entire email.  This option is useful if you like to review all the
message headers of an email, or if you wish to inspect the seperate
MIME parts for issues.

=cut

sub source {
	my(@mhpath)=($MH{'pathproc'});
	my($path, $raw)=(IO::Handle->new, IO::Handle->new);
	my($part)=int($PARTS[-1]{'part'}+1);
	my($msgfile);
	local($_);

	open($path, '-|', @mhpath, $MSG);
	while(<$path>) {
		chomp;
		$msgfile=$_;
	}
	close($path);

	return unless($msgfile && -s $msgfile);

	push(@PARTS, {
			'msg'		=> $MSG,
			'part'		=> $part,
			'type'		=> 'text/plain',
			'description'	=> 'View Message Source',
			'display'		=> 'View Source',
			'filename'	=> $msgfile,
			'size'		=> -s $msgfile,
		});

	open($raw, '<', $msgfile);
	while(<$raw>) {
		chomp;

		push(@{$CACHE{$PARTS[-1]}{'show'}}, expand($_));
	}
	$CACHE{$PARTS[-1]}{'source'}=1;
	close($raw);
}


sub info {
	my($part)=@_;

	unless($CACHE{$PARTS[$part]}{'info'}) {
		$CACHE{$PARTS[$part]}{'info'}=join("\n", '', map(
			sprintf('    %-15s %s', "$_:", $PARTS[$part]{$_}),
			sort(keys(%{$PARTS[$part]}))
		), '');
	}

	$BODY->text($CACHE{$PARTS[$part]}{'info'});
	#$BODY->focus();
}

sub user {
	my($view, $part)=@_;
	my($type, $subtype)=split(m(/), $PARTS[$part]{'type'});
	my(@mhstore)=($MH{'storemimeproc'});
	my(@show)=();
	my($body)=IO::Handle->new;
	my(@text)=();
	my($pause)=0;
	my($xstdin)=0;
	my($fh, $temp)=tempfile("schow${MSG}XXXXX", 'DIR' => $MH{'path'});
	local($_);

	unless($CACHE{$PARTS[$part]}{$view}) {
		if(exists($MH{"schow-$view-$type/$subtype"})) {
			push(@show, $MH{"schow-$view-$type/$subtype"});
		} elsif(exists($MH{"schow-$view-$type"})) {
			push(@show, $MH{"schow-$view-$type"});
		} else {
			$BODY->text('Cannot find an mh_profile entry for this type');
			return(1);
		}

		foreach(@show) {
			if(s|%l||g) {
				push(@text, sprintf('part %-8s %-25s %d',
					@{$PARTS[$part]}{'part', 'type', 'size'}));
			}
			if(s|%p||g) {
				$pause=1;
			}

			1 while(s|%\{(.*?)\}|$PARTS[$part]{$1}|);

			s|%a|$type/$subtype|g;
			s|'?%f'?|'$temp'|g;
			s|'?%F'?|'$temp'|g and $xstdin=1;
			s|%s|$subtype|g;
			s|%d|$PARTS[$part]{'description'}|g;
			s|%%|%|g;
		}

		system(@mhstore, '-outfile', $temp, '-part', $PARTS[$part]{'part'});

		if($xstdin) {
			$CUI->leave_curses();
			#mhshow uses shell interpolation, so I have to also :(
			if($xstdin) {
				system("@show");
			} else {
				system("@show <$temp");
			}
			if($pause) {
				print "\r                        \rPress [ENTER] to return";
				getc(STDIN);
			}
			$CUI->reset_curses();

			return(0);
		} else {
			#mhshow uses shell interpolation, so I have to also :(
			if($xstdin) {
				open($body, "@show |");
			} else {
				open($body, "@show <$temp |");
			}
			while(<$body>) {
				chomp;

				push(@text, $_);
			}
			close($body);

			unlink($temp);

			$CACHE{$PARTS[$part]}{$view}=\@text;
		}
	}

	$BODY->text(join("\n", @{$CACHE{$PARTS[$part]}{$view}}));
}

sub save {
	my($part)=@_;
	my(@mhstore)=($MH{'storemimeproc'});
	my($file)=$CUI->savefilebrowser(
		-path		=> $ENV{'PWD'},
		-file		=> $PARTS[$part]{'filename'},
		-editfilename	=> 1,
	);

	if($PARTS[$part]{'part'} && $file) {
		system(@mhstore, '-outfile', $file, '-part', $PARTS[$part]{'part'});
	}
	$BODY->focus();
}

sub open {
	my($part)=@_;
	my(@show)=($MH{'showmimeproc'}, '-form', 'mhl.body');

	if($PARTS[$part]{'part'}) {
		$CUI->leave_curses();
		system(@show, '-part', $PARTS[$part]{'part'});
		$CUI->reset_curses();
	}
	$BODY->focus();
}

sub editor {
	my($part)=@_;
	my(@mhstore)=($MH{'storemimeproc'});
	my(@editor)=($ARG{'editor'} || $MH{'editor'});
	my($fh, $temp)=tempfile("schow${MSG}XXXXX", 'DIR' => $MH{'path'});

	if($PARTS[$part]{'msg'} && $temp) {
		system('cp', '-a', $PARTS[$part]{'filename'}, $temp);

		$CUI->leave_curses();
		system(@editor, $temp);
		$CUI->reset_curses();
	} elsif($PARTS[$part]{'part'} && $temp) {
		system(@mhstore, '-outfile', $temp, '-part', $PARTS[$part]{'part'});

		$CUI->leave_curses();
		system(@editor, $temp);
		$CUI->reset_curses();
	}
	unlink($temp);
	$BODY->focus();
}

sub show {
	my($part)=@_;
	my(@show)=($MH{'showmimeproc'}, '-textonly', '-inlineonly',
		'-form', 'mhl.body', '-markform', '/dev/null');
	my($body)=IO::Handle->new;
	my(@text)=();
	my(@parts)=();
	my($line)=0;

	unless($CACHE{$PARTS[$part]}{'show'}) {
		if($part) {
			push(@parts, '-part', $PARTS[$part]{'part'});
		} else {
			foreach my $part (@PARTS) {
				unless($part->{'attachment'}) {
					push(@parts, '-part', $part->{'part'});
				}
			}
		}

		open($body, '-|', @show, @parts);
		while(<$body>) {
			chomp;
			$line++;

			if($line==1 && m|^part\s+\d+\s+\w+/.*\d+\w*$|) {
				next;
			}

			if(m/^\s{8}/ && length>$WIDTH) {
				s/^(\s+)(.*?)\s*$/$1$2$1/;
				while(length>$WIDTH && s/^\s//) {
					s/\s$//;
				}
			}
			push(@text, @{$CUI->text_wrap(expand($_), $WIDTH+1)});
		}
		close($body);

		foreach(@text) {
			s/\s+$//;
		}

		$CACHE{$PARTS[$part]}{'show'}=\@text;
	}

	$BODY->text(join("\n", @{$CACHE{$PARTS[$part]}{'show'}}));
	$BODY->draw(1);
	#$BODY->focus();
}

sub zoom {
	my($delta)=@_;
	my($part)=$MENU_PART->get();

	if($delta<0 && $WIDTH<=40) {
		return(undef);
	} elsif($delta>0 && $WIDTH>=320) {
		return(undef);
	}

	foreach my $part (values(%CACHE)) {
		delete($part->{'show'}) if(ref($part) eq 'HASH' && !$part->{'source'});
	}
	$WIDTH+=$delta;
	$ENV{'COLUMNS'}=$WIDTH;

	&show($part);
}

foreach my $view (grep(m/^schow-(show|about|open|save|editor)-/, keys(%MH))) {
	my($new)=$view;

	$new=~s/^schow-(show|about|open|save|editor)-/schow-${1}2-/;
	$MH{$new}=$MH{$view};
	delete($MH{$view});
}

sub view {
	local($_)=@_;
	my($type, $subtype)=split(m|/|);
	my(@views)=();
	my($text)='pgp-signature|x-c?sh|x-script|xml';

	foreach my $method (grep(m(^schow-.*?-$type(/$subtype)?$), keys(%MH))) {
		push(@views, $1) if($method=~m(^schow-(.*?)-$type));
	}

	if(m(text/plain)) {
		@views=('show', @views, 'about', 'editor', 'save');
	} elsif(m(text/)) {
		@views=('show', @views, 'about', 'open', 'editor', 'save');
	} elsif(m(message/)) {
		@views=('show', @views, 'about', 'open', 'save');
	} elsif(m(application/($text))) {
		@views=('show', @views, 'about', 'open', 'save');
	} else {
		@views=('about', @views, 'open', 'save');
	}

	return([@views]);
}

sub action {
	my($menu)=@_;
	my($part)=$MENU_PART->get();
	my($view)=$MENU_VIEW->get();

	if($menu==$MENU_PART) {
		$MENU_VIEW->{-values}=&view($PARTS[$part]{'type'});
		$MENU_VIEW->{-selected}=0;
		$MENU_VIEW->layout();
	}

	$view=$MENU_VIEW->get();

	if($view eq 'save') {
		&save($part);
		$MENU_VIEW->{-selected}=0;
	} elsif($view eq 'open') {
		&open($part);
		$MENU_VIEW->{-selected}=0;
	} elsif($view eq 'editor') {
		&editor($part);
		$MENU_VIEW->{-selected}=0;
	}

	$view=$MENU_VIEW->get();

	if($view eq 'show') {
		&show($part);
	} elsif($view eq 'about') {
		&info($part);
	} else {
		unless(&user($view, $part)) {
			$MENU_VIEW->{-selected}=0;
			$view=$MENU_VIEW->get();
		}
	}

	if($ARG{'boldbar'}) {
		$MENU_PART->{-canvasscr}->attron(A_BOLD);
		$MENU_VIEW->{-canvasscr}->attron(A_BOLD);
	}
	$MENU_PART->{-canvasscr}->attron(A_UNDERLINE);
	$MENU_VIEW->{-canvasscr}->attron(A_UNDERLINE);

	$MENU_PART->draw();
	$MENU_VIEW->draw();
}

sub window {
	$HEAD=$WIN->add('head', 'TextViewer',
		-height       => $HEADERS,
		-focusable    => 0,
		-text         => join("\n", @{$CACHE{'headers'}}),
		-nobeep       => $ARG{'nobeep'},
	);
	$MENU=$WIN->add('menu', 'Container',
		-y            => $HEADERS,
		-height       => 1,
	);
	$BODY=$WIN->add('body', 'TextViewer',
		-y            => $HEADERS+1,
		-showoverflow => 0,
		-nobeep       => $ARG{'nobeep'},
	);
}

sub menu {
	my($selected)=ref($MENU_PART)?($MENU_PART->get()):0;
	my($indexes)=[];
	my($labels)={};
	my($views)=[];

	for(my $i=0; $i<@PARTS; $i++) {
		next if($PARTS[$i]{'type'}=~m/multipart/);

		$labels->{$i}=$PARTS[$i]{'display'};
		push(@$indexes, $i);
	}

	$views=&view($PARTS[$part]{'type'});

	$BAR=$MENU->add('bar', 'Label',
		-textalignment => 'right',
		-width         => $Curses::COLS,
		-reverse       => $ARG{'inversebar'},
		-underline     => !$ARG{'inversebar'},
		-bold          => $ARG{'boldbar'},
		-paddingspaces => 1,
		-text          => $MSG.' ',
	);

	$MENU_PART=$MENU->add('part', 'Popupmenu',
		-x            => 2,
		-values       => $indexes,
		-labels       => $labels,
		-selected     => $selected,
		-wraparound   => 1,
		-onchange     => \&action,
		-sbborder     => 0,
		-nobeep       => $ARG{'nobeep'},
	);

	$MENU_VIEW=$MENU->add('view', 'Popupmenu',
		-x            => $MENU_PART->width()+3,
		-width        => 12,
		-values       => $views,
		-selected     => 0,
		-wraparound   => 1,
		-onchange     => \&action,
		-sbborder     => 0,
		-nobeep       => $ARG{'nobeep'},
	);

	$MENU->set_draworder('bar', 'part', 'view');
}

sub bindings {
	sub BINDc(&$@) { $_[1]->set_binding($_[0], @_[2 .. $#_]) }
	sub BINDs($$@) { $_[1]->set_binding($_[0], @_[2 .. $#_]) }
	sub hsend {
		foreach my $key (@_) {
			$HEAD->process_bindings($key);
		}
		$BODY->focus();
	}
	sub bsend {
		foreach my $key (@_) {
			$BODY->process_bindings($key);
		}
		$BODY->focus();
	}

	#Slide Head:
	BINDc { &hsend((KEY_RIGHT())x2) }  $WIN=>( '>', '.', "\e261-1" );
	BINDc { &hsend((KEY_LEFT())x2) }   $WIN=>( '<', ',', "\e260-1" );
	BINDc { &hsend((KEY_UP())) }       $WIN=>( "\e259-1" );
	BINDc { &hsend((KEY_DOWN())) }     $WIN=>( "\e258-1" );

	#Editor motions:
	BINDs 'cursor-up',                 $BODY=>( 'p', 'P', 'y', 'Y', "\K" );
	BINDs 'cursor-pageup',             $BODY=>( 'b', 'B', 'w', 'W' );
	BINDc { &bsend((KEY_UP())x11) }    $BODY=>( 'u', 'U', "\cU" );
	BINDc { &bsend((KEY_PPAGE())x20) } $BODY=>( 'g' );

	BINDs 'cursor-down',               $BODY=>( 'n', 'N', 's', 'S', 'e', 'E' );
	BINDs 'cursor-pagedown',           $BODY=>( 'f', "\cF", 'z', 'Z' );
	BINDc { &bsend((KEY_DOWN())x11) }  $BODY=>( 'd', 'D', "\cD" );
	BINDc { &bsend((KEY_NPAGE())x20) } $BODY=>( KEY_END(), 'G' );

	$BODY->set_mouse_binding( sub { &bsend(KEY_UP()) }, 65536);
	$BODY->set_mouse_binding( sub { &bsend(KEY_DOWN()) }, 2097152);

	#Cycle:
	if(@PARTS>1) {
		BINDc { $MENU_PART->focus() } $BODY=>( "\t" );
		BINDc { $MENU_PART->focus() }  $WIN=>( 'a', 'A' );
	} else {
		BINDc { $MENU_VIEW->focus() } $BODY=>( "\t" );
	}
	BINDc { $MENU_VIEW->focus() }      $BODY=>( KEY_BTAB );
	BINDc { $MENU_VIEW->focus() }       $WIN=>( 'v', 'V' );

	BINDc { $MENU_VIEW->focus() } $MENU_PART=>( KEY_LEFT, KEY_RIGHT, "\t" );
	BINDc { $BODY->focus() }      $MENU_PART=>( KEY_BTAB );

	if(@PARTS>1) {
		BINDc { $MENU_PART->focus() }
		                         $MENU_VIEW=>( KEY_LEFT, KEY_RIGHT, KEY_BTAB);
	} else {
		BINDc { 'noop'; }        $MENU_VIEW=>( KEY_LEFT, KEY_RIGHT );
		BINDc { $BODY->focus() } $MENU_VIEW=>( KEY_BTAB );
	}
	BINDc { $BODY->focus() }      $MENU_VIEW=>( "\t" );

	#View menu:
	BINDs 'open-popup',           $MENU_VIEW=>( KEY_UP, KEY_DOWN );

	#Zoom:
	BINDc { &zoom(20) }                 $CUI=>( '+', '=' );
	BINDc { &zoom(-20) }                $CUI=>( '-', '_' );

	#Global Keys
	BINDc { $BODY->focus() }            $CUI=>( "\e" );
	BINDc { $CUI->mainloopExit }        $CUI=>( 'q', 'Q', 'x', 'X', "\cC" );
	BINDc { $CUI->{-canvasscr}->redrawwin() }
	                                    $CUI=>( 'r', 'R', "\cR", "\cL" );
}

sub status {
	$BAR->text(join(' ', @_, '', $MSG, ''));
}

sub display {
	my($msg)=@_;

	&parts();
	&source() if($ARG{'source'});
	&headers();

	&window();
	&menu();
	&bindings();

	&action($MENU_PART);

	$BODY->focus();

	$CUI->mainloop;

	return;
}

sub messages {
	my(@msgs)=();

	foreach my $seq (@_) {
		push(@msgs, shellwords(`$MH{'pickproc'} $seq`));
	}

	foreach my $msg (@msgs) {
		%CACHE=();
		&mark($msg);
		&display($msg);
	}
}

if(@ARGV) {
	&messages(@ARGV);
} else {
	&messages('cur');
}

$CUI->leave_curses();
print "\n";

=head1 EXAMPLES

B<schow> can be called directly, or configured as your MIME show proc
for specific binaries.
C<DO NOT SET schow AS showmimeproc IN YOUR .mh_profile>.
Doing so will have disasterous consequences for any program expecting
to read from C<mhshow>, really please don't try it.  B<schow> itself,
needs access to the C<mhshow> binary, and looks at the C<showmimeproc>
variable in your F<.mh_profile> to find it.  You can, however,
specify that standard interactive commands use B<schow> for displaying
MIME message by placing the following in your F<.mh_profile>:

  show: -showmimeproc schow
  prev: -showmimeproc schow
  next: -showmimeproc schow

Assuming, of course, that B<schow> is in your path.  If you prefer to use
the standard commands most of the time, and save B<schow> for occasions
where messages are complex, remember that C<schow>, C<schow prev>, and
C<schow next> will work the same as C<show>, C<prev>, and C<next>,
respectively.

=head1 AUTHOR

William Totten

=head1 LICENSE

BSD 3-Clause License

=head1 COPYRIGHT

  Copyright (c) 2017, William Totten
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  
  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=cut

